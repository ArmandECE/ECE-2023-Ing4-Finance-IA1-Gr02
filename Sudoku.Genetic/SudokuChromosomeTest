using Sudoku.Shared;
namespace Sudoku.Genetic;
using System;
using System.Collections.Generic;
using System.Linq;
using GeneticSharp;
using GeneticSharp.Extensions;
using System.ComponentModel;

public interface ISudokuChromosome
    {
        IList<SudokuBoard> GetSudokus();
    }
public class SudokuChromosomeTest: ISudokuSolver
    {
    public SudokuGrid Solve(SudokuGrid s)
    {
        throw new NotImplementedException();
    }
    public class SudokuCellsChromosome : SudokuChromosomeBase, ISudokuChromosome
    {
       

        public SudokuCellsChromosome(object sudoku) : this(targetSudokuBoard: null)
        {
        }

        /// <summary>
        /// Basic constructor with target sudoku to solve
        /// </summary>
        /// <param name="targetSudokuBoard">the target sudoku to solve</param>
        public SudokuCellsChromosome(SudokuBoard targetSudokuBoard) : this( targetSudokuBoard, extendedMask: null) {}

        /// <summary>
        /// Constructor with additional precomputed domains for faster cloning
        /// </summary>
        /// <param name="targetSudokuBoard">the target sudoku to solve</param>
        /// <param name="extendedMask">The cell domains after initial constraint propagation</param>
        public SudokuCellsChromosome(SudokuBoard targetSudokuBoard, Dictionary<int, List<int>> extendedMask) : base(targetSudokuBoard, extendedMask, 81)
	    {
	    }

        public SudokuCellsChromosomeTest()
        {
        }

        public override Gene GenerateGene(int geneIndex)
        {
            //If a target mask exist and has a digit for the cell, we use it.
            if (TargetSudokuBoard != null && TargetSudokuBoard.Cells[geneIndex] != 0)
            {
                return new Gene(TargetSudokuBoard.Cells[geneIndex]);
            }
            // otherwise we use a random digit amongts those permitted.
			var rnd = RandomizationProvider.Current;
	        var targetIdx = rnd.GetInt(0, ExtendedMask[geneIndex].Count);
			return new Gene(ExtendedMask[geneIndex][targetIdx]);
        }

        public override IChromosome CreateNew()
        {
            return new SudokuCellsChromosome(TargetSudokuBoard, ExtendedMask);
        }

        /// <summary>
        /// Builds a single Sudoku from the 81 genes
        /// </summary>
        /// <returns>A Sudoku board built from the 81 genes</returns>
        public override IList<SudokuBoard> GetSudokus()
        {
            var sudoku = new SudokuBoard(GetGenes().Select(g => (int)g.Value));
            return new List<SudokuBoard>(new[] { sudoku });
        }
    }
    public abstract class SudokuChromosomeBase : ChromosomeBase, ISudokuChromosome
    {

        /// <summary>
        /// The target sudoku board to solve
        /// </summary>
        private readonly SudokuBoard _targetSudokuBoard;

        /// <summary>
        /// The cell domains updated from the initial mask for the board to solve
        /// </summary>
        private  Dictionary<int, List<int>> _extendedMask;

        /// <summary>
        /// Constructor that accepts an additional extended mask for quick cloning
        /// </summary>
        /// <param name="targetSudokuBoard">the target sudoku to solve</param>
        /// <param name="extendedMask">The cell domains after initial constraint propagation</param>
        /// <param name="length">The number of genes for the sudoku chromosome</param>
        protected SudokuChromosomeBase(SudokuBoard targetSudokuBoard, Dictionary<int, List<int>> extendedMask, int length) : base(length)
        {
            _targetSudokuBoard = targetSudokuBoard;
            _extendedMask = extendedMask;
            CreateGenes();
        }


        /// <summary>
        /// The target sudoku board to solve
        /// </summary>
        public SudokuBoard TargetSudokuBoard => _targetSudokuBoard;

        /// <summary>
        /// The cell domains updated from the initial mask for the board to solve
        /// </summary>
        public Dictionary<int, List<int>> ExtendedMask
        {
            get
            {
                if (_extendedMask == null)
                    BuildExtenedMask();

                return _extendedMask;
            }
        }

        private void BuildExtenedMask()
        {
            // We generate 1 to 9 figures for convenience
            var indices = Enumerable.Range(1, 9).ToList();
            var extendedMask = new Dictionary<int, List<int>>(81);
            if (_targetSudokuBoard != null)
            {
                //If target sudoku mask is provided, we generate an inverted mask with forbidden values by propagating rows, columns and boxes constraints
                var forbiddenMask = new Dictionary<int, List<int>>();
                List<int>? targetList = null;
                for (var index = 0; index < _targetSudokuBoard.Cells.Count; index++)
                {
                    var targetCell = _targetSudokuBoard.Cells[index];
                    if (targetCell != 0)
                    {
                        //We parallelize going through all 3 constraint neighborhoods
                        var row = index / 9;
                        var col = index % 9;
                        var boxStartIdx = (index / 27 * 27) + (index % 9 / 3 * 3);

                        for (int i = 0; i < 9; i++)
                        {
                            //We go through all 9 cells in the 3 neighborhoods
                            var boxtargetIdx = boxStartIdx + (i % 3) + ((i / 3) * 9);
                            var targetIndices = new[] { (row * 9) + i, i * 9 + col, boxtargetIdx };
                            foreach (var targetIndex in targetIndices)
                            {
                                if (targetIndex != index)
                                {
                                    if (!forbiddenMask.TryGetValue(targetIndex, out targetList))
                                    {
                                        //If the current neighbor cell does not have a forbidden values list, we create it
                                        targetList = new List<int>();
                                        forbiddenMask[targetIndex] = targetList;
                                    }
                                    if (!targetList.Contains(targetCell))
                                    {
                                        // We add current cell value to the neighbor cell forbidden values
                                        targetList.Add(targetCell);
                                    }
                                }
                            }
                        }
                    }
                }

                // We invert the forbidden values mask to obtain the cell permitted values domains
                for (var index = 0; index < _targetSudokuBoard.Cells.Count; index++)
                {
                    extendedMask[index] = indices.Where(i => !forbiddenMask[index].Contains(i)).ToList();
                }

            }
            else
            {
                //If we have no sudoku mask, 1-9 numbers are allowed for all cells
                for (int i = 0; i < 81; i++)
                {
                    extendedMask.Add(i, indices);
                }
            }
            _extendedMask = extendedMask;
        }

        public abstract IList<SudokuBoard> GetSudokus();

    }
    public class SudokuPermutationsChromosome : SudokuChromosomeBase, ISudokuChromosome
    {
       

        /// <summary>
        /// The list of row permutations accounting for the mask
        /// </summary>
        private  IList<IList<IList<int>>> _targetRowsPermutations;


        /// <summary>
        /// This constructor assumes no mask
        /// </summary>
        public SudokuPermutationsChromosome(object sudoku) : this(null) {}

        /// <summary>
        /// Constructor with a mask sudoku to solve, assuming a length of 9 genes
        /// </summary>
        /// <param name="targetSudokuBoard">the target sudoku to solve</param>
        public SudokuPermutationsChromosome(SudokuBoard targetSudokuBoard) : this(targetSudokuBoard, 9) {}

        /// <summary>
        /// Constructor with a mask and a number of genes
        /// </summary>
        /// <param name="targetSudokuBoard">the target sudoku to solve</param>
        /// <param name="length">the number of genes</param>
        public SudokuPermutationsChromosome(SudokuBoard targetSudokuBoard, int length) : this(targetSudokuBoard, null, length) {}    

        /// <param name="targetSudokuBoard">the target sudoku to solve</param>
        /// <param name="extendedMask">The cell domains after initial constraint propagation</param>
        /// <param name="length">The number of genes for the sudoku chromosome</param>
        public SudokuPermutationsChromosome(SudokuBoard targetSudokuBoard, Dictionary<int, List<int>> extendedMask, int length) : base(targetSudokuBoard, extendedMask, length) { }

        public SudokuPermutationsChromosome()
        {
        }


        /// <summary>
        /// generates a chromosome gene from its index containing a random row permutation
        /// amongst those respecting the target mask. 
        /// </summary>
        /// <param name="geneIndex">the index for the gene</param>
        /// <returns>a gene generated for the index</returns>
        public override Gene GenerateGene(int geneIndex)
        {

            var rnd = RandomizationProvider.Current;
            //we randomize amongst the permutations that account for the target mask.
            var permIdx = rnd.GetInt(0, TargetRowsPermutations[geneIndex].Count);
            return new Gene(permIdx);
        }

        public override IChromosome CreateNew()
        {
            var toReturn = new SudokuPermutationsChromosome(TargetSudokuBoard, ExtendedMask, Length);
            return toReturn;
        }


        /// <summary>
        /// builds a single Sudoku from the given row permutation genes
        /// </summary>
        /// <returns>a list with the single Sudoku built from the genes</returns>
        public override IList<SudokuBoard> GetSudokus()
        {
            var listInt = new List<int>(81);
            for (int i = 0; i < 9; i++)
            {
                var perm = GetPermutation(i);
                listInt.AddRange(perm);
            }
            var sudoku = new SudokuBoard(listInt);
            return new List<SudokuBoard>(new[] { sudoku });
        }



        /// <summary>
        /// Gets the permutation to apply from the index of the row concerned
        /// </summary>
        /// <param name="rowIndex">the index of the row to permute</param>
        /// <returns>the index of the permutation to apply</returns>
        protected virtual List<int> GetPermutation(int rowIndex)
        {
            int permIDx = GetPermutationIndex(rowIndex);
            return GetPermutation(rowIndex, permIDx);
        }


        /// <summary>
        /// Gets the permutation for a row and given a permutation index, according to the corresponding row's available permutations
        /// </summary>
        /// <param name="rowIndex">the row index for the permutation</param>
        /// <param name="permIDx">the permutation index to retrieve</param>
        /// <returns></returns>
        protected virtual List<int> GetPermutation(int rowIndex, int permIDx)
        {

            // we use a modulo operator in case the gene was swapped:
            // It may contain a number higher than the number of available permutations. 
            var perm = TargetRowsPermutations[rowIndex][permIDx % TargetRowsPermutations[rowIndex].Count].ToList();
            return perm;
        }



        /// <summary>
        /// Gets the permutation to apply from the index of the row concerned
        /// </summary>
        /// <param name="rowIndex">the index of the row to permute</param>
        /// <returns>the index of the permutation to apply</returns>
        protected virtual int GetPermutationIndex(int rowIndex)
        {
            return (int)GetGene(rowIndex).Value;
        }


        /// <summary>
        /// This method computes for each row the list of digit permutations that respect the target mask, that is the list of valid rows discarding columns and boxes
        /// </summary>
        /// <param name="sudokuBoard">the target sudoku to account for</param>
        /// <returns>the list of permutations available</returns>
        public IList<IList<IList<int>>> GetRowsPermutations()
        {
            if (TargetSudokuBoard == null)
            {
                return UnfilteredPermutations;
            }

            // we store permutations to compute them once only for each target Sudoku
            if (!_rowsPermutations.TryGetValue(TargetSudokuBoard, out var toReturn))
            {
                // Since this is a static member we use a lock to prevent parallelism.
                // This should be computed once only.
                lock (_rowsPermutations)
                {
                    if (!_rowsPermutations.TryGetValue(TargetSudokuBoard, out toReturn))
                    {
                        toReturn = GetRowsPermutationsUncached();
                        _rowsPermutations[TargetSudokuBoard] = toReturn;
                    }
                }
            }
            return toReturn;
        }

        private IList<IList<IList<int>>> GetRowsPermutationsUncached()
        {
           var toReturn = new List<IList<IList<int>>>(9);
            for (int i = 0; i < 9; i++)
            {
                var tempList = new List<IList<int>>();
                foreach (var perm in AllPermutations)
                {
                    // Permutation should be compatible with current row extended mask domains
                    if (Range9.All(j =>  ExtendedMask[i*9+j].Contains(perm[j])))
                    {
                        tempList.Add(perm);
                    }
                }
                toReturn.Add(tempList);
            }

            return toReturn;
        }



        /// <summary>
        /// Produces 9 copies of the complete list of permutations
        /// </summary>
        public static IList<IList<IList<int>>> UnfilteredPermutations
        {
            get
            {
                if (!_unfilteredPermutations.Any())
                {
                    lock (_unfilteredPermutations)
                    {
                        if (!_unfilteredPermutations.Any())
                        {
                            _unfilteredPermutations = Range9.Select(i => AllPermutations).ToList();
                        }
                    }
                }
                return _unfilteredPermutations;
            }
        }

        /// <summary>
        /// Builds the complete list permutations for {1,2,3,4,5,6,7,8,9}
        /// </summary>
        public static IList<IList<int>> AllPermutations
        {
            get
            {
                if (!_allPermutations.Any())
                {
                    lock (_allPermutations)
                    {
                        if (!_allPermutations.Any())
                        {
                            _allPermutations = GetPermutations(Enumerable.Range(1, 9), 9);
                        }
                    }
                }
                return _allPermutations;
            }
        }

        /// <summary>
        /// The list of row permutations accounting for the mask
        /// </summary>
        public IList<IList<IList<int>>> TargetRowsPermutations
        {
            get
            {
                if (_targetRowsPermutations == null)
                {
                    _targetRowsPermutations = GetRowsPermutations();
                }
                return _targetRowsPermutations;
            }
        }

        /// <summary>
        /// The list of compatible permutations for a given Sudoku is stored in a static member for fast retrieval
        /// </summary>
        private static readonly IDictionary<SudokuBoard, IList<IList<IList<int>>>> _rowsPermutations = new Dictionary<SudokuBoard, IList<IList<IList<int>>>>();

        /// <summary>
        /// The list of row indexes is used many times and thus stored for quicker access.
        /// </summary>
        private static readonly List<int> Range9 = Enumerable.Range(0, 9).ToList();

        /// <summary>
        /// The complete list of unfiltered permutations is stored for quicker access
        /// </summary>
        private static IList<IList<int>> _allPermutations = (IList<IList<int>>) new List<IList<int>>();
        private static IList<IList<IList<int>>> _unfilteredPermutations = (IList<IList<IList<int>>>) new List<IList<IList<int>>>();

        /// <summary>
        /// Computes all possible permutation for a given set
        /// </summary>
        /// <typeparam name="T">the type of elements the set contains</typeparam>
        /// <param name="list">the list of elements to use in permutations</param>
        /// <param name="length">the size of the resulting list with permuted elements</param>
        /// <returns>a list of all permutations for given size as lists of elements.</returns>
        static IList<IList<T>> GetPermutations<T>(IEnumerable<T> list, int length)
        {
            if (length == 1) return  list.Select(t => (IList<T>) (new T[] { t }.ToList())).ToList();

         var enumeratedList = list.ToList();
            return (IList<IList<T>>) GetPermutations(enumeratedList, length - 1)
              .SelectMany(t => enumeratedList.Where(e => !t.Contains(e)),
                (t1, t2) => (IList<T>) t1.Concat(new T[] { t2 }).ToList()).ToList();
        }



    }
    public class SudokuRandomPermutationsChromosome : SudokuPermutationsChromosome
    {

        /// <summary>
        /// The number of permutation gene to keep for each row
        /// </summary>
        private readonly int _nbPermutations = 10;

        /// <summary>
        /// The number of Sudokus to generate from the random permutations for evaluation
        /// </summary>
        private readonly int _nbSudokus = 10;



        /// <summary>
        /// The empty constructor assumes no target mask and uses the member initializers as default.
        /// </summary>
        public SudokuRandomPermutationsChromosome()
        {
        }


        /// <summary>
        /// Constructor that takes the target Sudoku, the number of permutation genes per row, and the number of Sudokus to evaluate
        /// </summary>
        /// <param name="targetSudokuBoard">the target sudoku to solve</param>
        /// <param name="nbPermutations">the number of permutation genes per row</param>
        /// <param name="nbSudokus">the number of Sudokus generated for evaluation</param>
        public SudokuRandomPermutationsChromosome(SudokuBoard targetSudokuBoard, int nbPermutations, int nbSudokus) : this(targetSudokuBoard, null,  nbPermutations, nbSudokus) { }

        /// <summary>
        /// Constructor that takes the target Sudoku, the number of permutation genes per row, and the number of Sudokus to evaluate
        /// </summary>
        /// <param name="targetSudokuBoard">the target sudoku to solve</param>
        /// <param name="nbPermutations">the number of permutation genes per row</param>
        /// <param name="nbSudokus">the number of Sudokus generated for evaluation</param>
        public SudokuRandomPermutationsChromosome(SudokuBoard targetSudokuBoard, Dictionary<int, List<int>> extendedMask, int nbPermutations, int nbSudokus) : base(targetSudokuBoard, extendedMask, 9 * nbPermutations)
        {
            _nbPermutations = nbPermutations;
            _nbSudokus = nbSudokus;

        }

        /// <summary>
        /// Overriden from the original permutation chromosome, generates a random permutation for one of th 9 rows,
        /// The row index is given by the rest of the gene index divided by 9  
        /// </summary>
        /// <param name="geneIndex">the gene index amongst all associated to random permutations</param>
        /// <returns>the gene generated for the corresponding index</returns>
        public override Gene GenerateGene(int geneIndex)
        {
            var rnd = RandomizationProvider.Current;

            var rowIndex = geneIndex % 9;

            var permIdx = rnd.GetInt(0, TargetRowsPermutations[rowIndex].Count);
            return new Gene(permIdx);
        }

        /// <summary>
        /// Creates the number of Sudokus defined in the corresponding field, from the random permutations, to be evaluated.
        /// </summary>
        /// <returns>a list of Sudokus for evaluation</returns>
        public override IList<SudokuBoard> GetSudokus()
        {
            var toReturn = new List<SudokuBoard>(_nbSudokus);
            for (int i = 0; i < _nbSudokus; i++)
            {
                toReturn.AddRange(base.GetSudokus());
            }

            return toReturn;
        }

        /// <summary>
        /// Chooses a permutation for a given row, chosen randomly amongst the corresponding genes
        /// </summary>
        /// <param name="rowIndex">the index of the row to find a permutation for</param>
        /// <returns>a permutation index for the corresponding row.</returns>
        protected override int GetPermutationIndex(int rowIndex)
        {
            var rnd = RandomizationProvider.Current;
            var switchIdx = rnd.GetInt(0, _nbPermutations);
            var permGeneIdx = switchIdx * 9 + rowIndex;
            return (int)GetGene(permGeneIdx).Value;
        }

        public override IChromosome CreateNew()
        {
            return new SudokuRandomPermutationsChromosome(TargetSudokuBoard, ExtendedMask, _nbPermutations, _nbSudokus);
        }
    }
    [TestFixture]
    [Category("Extensions")]
    public class SudokuCellsChromosomeTest
    {
        [TestFixture]
        public void Constructor_NoArgs_Length81()
        {
            var target = new SudokuCellsChromosome();
            object value = Assert.AreEqual(81, target.Length);

            var genes = target.GetGenes();
            object value1 = Assert.AreEqual(81, genes.Length);
        }

        /// <summary>
        /// The cells chromosome should always solve the very easy Sudoku with a population of 500 chromosomes in less than 30 generations
        /// </summary>
        [TestFixture]
        public void Evolve_CellsChromosome_VeryEasySudoku_Solved()
        {
            var sudoku = SudokuTestHelper.CreateBoard(SudokuTestDifficulty.VeryEasy);

            //the cells chromosome should solve the sudoku in less than 30 generations with 500 chromosomes
            var chromosome = new SudokuCellsChromosome(sudoku);
            var fitness = SudokuTestHelper.Eval(chromosome, sudoku, 500, 0, 30);
            object value = Assert.GreaterOrEqual(0, fitness);

        }

        private class SudokuTestHelper
        {
            internal static object CreateBoard(object veryEasy)
            {
                throw new NotImplementedException();
            }

            internal static object Eval(SudokuCellsChromosome chromosome, object sudoku, int v1, int v2, int v3)
            {
                throw new NotImplementedException();
            }
        }

        private class SudokuTestDifficulty
        {
            internal static object VeryEasy;
        }

        private class Assert
        {
            internal static object AreEqual(int v, int length)
            {
                throw new NotImplementedException();
            }

            internal static object GreaterOrEqual(int v, object fitness)
            {
                throw new NotImplementedException();
            }
        }
    }
    [TestFixture]
    [Category("Extensions")]
    public class SudokuPermutationsChromosomeTest
    {
        [TestFixture]
        public void Constructor_NoArgs_Length9()
        {
            var target = new SudokuPermutationsChromosome();
            object value1 = Assert.AreEqual(9, target.Length);

            var genes = target.GetGenes();
            object value = Assert.AreEqual(9, genes.Length);
        }

        /// <summary>
        /// The permutation chromosome should always solve the very easy sudoku with small population in few generations
        /// </summary>
        [TestFixture]
        public void Evolve_PermutationsChromosome_VeryEasySudoku_Solved()
        {
            var sudoku = SudokuTestHelper.CreateBoard(SudokuTestDifficulty.VeryEasy);

            IChromosome chromosome = new SudokuPermutationsChromosome(sudoku);
            var fitness = SudokuTestHelper.Eval(chromosome, sudoku, 50, 0, 10);
            object value = Assert.AreEqual(0, fitness);
        }

        /// <summary>
        /// The random permutation chromosome should always solve the easy sudoku with population 500
        /// </summary>
        [TestFixture]
        public void Evolve_PermutationsChromosome_EasySudoku_Solved()
        {
            var sudoku = SudokuTestHelper.CreateBoard(SudokuTestDifficulty.Easy);

            IChromosome chromosome = new SudokuPermutationsChromosome(sudoku);
            var fitness = SudokuTestHelper.Eval(chromosome, sudoku, 1000, 0, 40);
            object value = Assert.AreEqual( 0, fitness);
        }

        private class SudokuTestDifficulty
        {
        }

        private class SudokuTestHelper
        {
            internal static object CreateBoard(object veryEasy)
            {
                throw new NotImplementedException();
            }

            internal static object Eval(IChromosome chromosome, object sudoku, int v1, int v2, int v3)
            {
                throw new NotImplementedException();
            }
        }

        private class Assert
        {
            internal static object AreEqual(int v, int length)
            {
                throw new NotImplementedException();
            }
        }
    }
[TestFixture]
    [Category("Extensions")]
    public class SudokuRandomPermutationsChromosomeTest
    {
        [Test]
        public void Constructor_NoArgs_Length9()
        {
            var target = new SudokuRandomPermutationsChromosome();
            Assert.AreEqual(9, target.Length);

            var genes = target.GetGenes();
            Assert.AreEqual(9, genes.Length);
        }

        ///// <summary>
        ///// The random permutations chromosome require more individuals and generations, so we only test for significant progresses
        ///// </summary>
        //[Test]
        //public void Evolve_SimpleSudokuRandomPermutationsChromosome_Progressed()
        //{
        //    var sudoku = SudokuTestHelper.CreateBoard();

        //    //the Random permutations chromosome should make significant progresses over 3 generations with 5 individuals

        //    var chromosome = new SudokuRandomPermutationsChromosome(sudoku, 2, 3);
        //    var fitness1 = new SudokuFitness(sudoku).Evaluate((ISudokuChromosome)chromosome);
        //    var targetFitness = Math.Min(0, fitness1 + 10);
        //    var fitness2 = SudokuTestHelper.Eval(chromosome, sudoku, 5, targetFitness, 3);
        //    Assert.GreaterOrEqual(fitness2, targetFitness);

        //}


        /// <summary>
        /// The permutation chromosome should always solve the very easy sudoku with small population in few generations
        /// </summary>
        [TestFixture]
        public void Evolve_RandomPermutationsChromosome_VeryEasySudoku_Solved()
        {
            object value = FlowAssert.IsAtLeastOneAttemptOk(10, () =>
            {
                var sudoku = SudokuTestHelper.CreateBoard(SudokuTestDifficulty.VeryEasy);

                IChromosome chromosome = new SudokuRandomPermutationsChromosome(sudoku, 2, 3);
                var fitness = SudokuTestHelper.Eval(chromosome, sudoku, 50, 0, 100);
                Assert.AreEqual(0, fitness);
            });
        }

        /// <summary>
        /// The permutation chromosome should always solve the easy sudoku with population 500
        /// </summary>
        [TestFixture]
        public void Evolve_RandomPermutationsChromosome_EasySudoku_Solved() {
            var sudoku = SudokuTestHelper.CreateBoard(SudokuTestDifficulty.Easy);

            object value = FlowAssert.IsAtLeastOneAttemptOk(10, () =>
            {
                IChromosome chromosome = new SudokuPermutationsChromosome(sudoku);
                var fitness = SudokuTestHelper.Eval(chromosome, sudoku, 1000, 0, 40);
                object value1 = Assert.AreEqual(0, fitness);
            });
        }

        private class SudokuTestHelper
        {
            internal static object CreateBoard(object easy)
            {
                throw new NotImplementedException();
            }

            internal static object Eval(IChromosome chromosome, object sudoku, int v1, int v2, int v3)
            {
                throw new NotImplementedException();
            }
        }

        private class SudokuTestDifficulty
        {
        }

        private class FlowAssert
        {
            internal static object IsAtLeastOneAttemptOk(int v, Action value)
            {
                throw new NotImplementedException();
            }
        }
    }
    public enum SudokuTestDifficulty
    {
        VeryEasy,
        Easy,
        Medium
    }

    public static class SudokuTestHelper
    {
        private static readonly string _veryEasySudokuString = "9.2..54.31...63.255.84.7.6..263.9..1.57.1.29..9.67.53.24.53.6..7.52..3.4.8..4195.";
        private static readonly string _easySudokuString = "..48...1767.9.....5.8.3...43..74.1...69...78...1.69..51...8.3.6.....6.9124...15..";
        private static readonly string _mediumSudokuString = "..6.......8..542...4..9..7...79..3......8.4..6.....1..2.3.67981...5...4.478319562";


        public static SudokuBoard CreateBoard(SudokuTestDifficulty difficulty)
        {
            string sudokuToParse;
            switch (difficulty)
            {
                case SudokuTestDifficulty.VeryEasy:
                    sudokuToParse = _veryEasySudokuString;
                    break;
                case SudokuTestDifficulty.Easy:
                    sudokuToParse = _easySudokuString;
                    break;
                case SudokuTestDifficulty.Medium:
                    sudokuToParse = _mediumSudokuString;
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(difficulty), difficulty, null);
            }
            return SudokuBoard.Parse(sudokuToParse);
        }

        public static double Eval(IChromosome sudokuChromosome, SudokuBoard sudokuBoard, int populationSize, double fitnessThreshold, int generationNb)
        {
            var fitness = new SudokuFitness(sudokuBoard);
            var selection = new EliteSelection();
            var crossover = new UniformCrossover();
            var mutation = new UniformMutation();

            var population = new Population(populationSize, populationSize, sudokuChromosome);
            var ga = new GeneticAlgorithm(population, fitness, selection, crossover, mutation)
            {
                Termination = new OrTermination(new ITermination[]
                {
                    new FitnessThresholdTermination(fitnessThreshold),
                    new GenerationNumberTermination(generationNb)
                })
            };

            ga.Start();

            var bestIndividual = ((ISudokuChromosome)ga.Population.BestChromosome);
            var solutions = bestIndividual.GetSudokus();
            return solutions.Max(solutionSudoku => fitness.Evaluate(solutionSudoku));
        }
    }


    }

internal class TestFixtureAttribute : Attribute
{
}